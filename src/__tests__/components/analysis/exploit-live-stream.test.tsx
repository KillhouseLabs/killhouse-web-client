import React from "react";
import { render, screen, waitFor, act } from "@testing-library/react";
import { ExploitLiveStream } from "@/components/analysis/exploit-live-stream";

// Mock EventSource
class MockEventSource {
  static instances: MockEventSource[] = [];
  url: string;
  listeners: Record<string, ((event: MessageEvent) => void)[]> = {};
  onerror: ((event: Event) => void) | null = null;
  onopen: (() => void) | null = null;

  constructor(url: string) {
    this.url = url;
    MockEventSource.instances.push(this);
    // Simulate connection after a short delay
    setTimeout(() => {
      if (this.onopen) this.onopen();
    }, 0);
  }

  addEventListener(type: string, listener: (event: MessageEvent) => void) {
    if (!this.listeners[type]) this.listeners[type] = [];
    this.listeners[type].push(listener);
  }

  removeEventListener() {}

  close() {}

  // Test helper: simulate an SSE event
  emit(type: string, data: object) {
    act(() => {
      const event = { data: JSON.stringify(data) } as MessageEvent;
      (this.listeners[type] || []).forEach((fn) => fn(event));
    });
  }
}

describe("ExploitLiveStream", () => {
  let originalEventSource: typeof EventSource | undefined;

  beforeAll(() => {
    originalEventSource = (global as any).EventSource;
    (global as any).EventSource = MockEventSource;
  });

  afterAll(() => {
    if (originalEventSource) {
      (global as any).EventSource = originalEventSource;
    } else {
      delete (global as any).EventSource;
    }
  });

  beforeEach(() => {
    MockEventSource.instances = [];
    process.env.NEXT_PUBLIC_EXPLOIT_AGENT_URL = "http://localhost:8000";
  });

  afterEach(() => {
    delete process.env.NEXT_PUBLIC_EXPLOIT_AGENT_URL;
  });

  it("GIVEN no NEXT_PUBLIC_EXPLOIT_AGENT_URL WHEN rendered THEN shows error message", async () => {
    delete process.env.NEXT_PUBLIC_EXPLOIT_AGENT_URL;
    render(<ExploitLiveStream exploitSessionId="test-session" />);

    await waitFor(() => {
      expect(screen.getByText(/연결 실패/)).toBeInTheDocument();
    });
  });

  it("GIVEN valid config WHEN rendered THEN connects to correct SSE URL", async () => {
    render(<ExploitLiveStream exploitSessionId="test-session-123" />);

    await waitFor(() => {
      expect(MockEventSource.instances).toHaveLength(1);
      expect(MockEventSource.instances[0].url).toBe(
        "http://localhost:8000/api/sessions/test-session-123/stream"
      );
    });
  });

  it("GIVEN thought event WHEN received THEN displays thought text", async () => {
    render(<ExploitLiveStream exploitSessionId="test-session" />);

    await waitFor(() => {
      expect(MockEventSource.instances).toHaveLength(1);
    });

    const eventSource = MockEventSource.instances[0];
    eventSource.emit("thought", {
      iteration: 1,
      thought: "Analyzing SQL injection vulnerability",
      vulnerability_type: "SQL Injection",
    });

    await waitFor(() => {
      expect(
        screen.getByText(/Analyzing SQL injection vulnerability/)
      ).toBeInTheDocument();
      expect(screen.getByText(/SQL Injection/)).toBeInTheDocument();
    });
  });

  it("GIVEN command event WHEN received THEN displays tool name", async () => {
    render(<ExploitLiveStream exploitSessionId="test-session" />);

    await waitFor(() => {
      expect(MockEventSource.instances).toHaveLength(1);
    });

    const eventSource = MockEventSource.instances[0];
    eventSource.emit("command", {
      tool: "curl",
      arguments: { url: "http://example.com", method: "POST" },
      iteration: 1,
    });

    await waitFor(() => {
      expect(screen.getByText("curl")).toBeInTheDocument();
    });
  });

  it("GIVEN result event with success WHEN received THEN shows success badge", async () => {
    render(<ExploitLiveStream exploitSessionId="test-session" />);

    await waitFor(() => {
      expect(MockEventSource.instances).toHaveLength(1);
    });

    const eventSource = MockEventSource.instances[0];
    eventSource.emit("result", {
      vulnerability_type: "XSS",
      location: "/api/search",
      success: true,
      evidence: "Alert popup triggered",
    });

    await waitFor(() => {
      expect(screen.getByText("침투 성공")).toBeInTheDocument();
      expect(screen.getByText("XSS")).toBeInTheDocument();
    });
  });

  it("GIVEN result event with failure WHEN received THEN shows failure badge", async () => {
    render(<ExploitLiveStream exploitSessionId="test-session" />);

    await waitFor(() => {
      expect(MockEventSource.instances).toHaveLength(1);
    });

    const eventSource = MockEventSource.instances[0];
    eventSource.emit("result", {
      vulnerability_type: "CSRF",
      location: "/api/update",
      success: false,
    });

    await waitFor(() => {
      expect(screen.getByText("침투 실패")).toBeInTheDocument();
      expect(screen.getByText("CSRF")).toBeInTheDocument();
    });
  });

  it("GIVEN done event WHEN received THEN shows summary", async () => {
    render(<ExploitLiveStream exploitSessionId="test-session" />);

    await waitFor(() => {
      expect(MockEventSource.instances).toHaveLength(1);
    });

    const eventSource = MockEventSource.instances[0];
    eventSource.emit("done", {
      status: "success",
      exploited_count: 3,
      failed_count: 1,
    });

    await waitFor(() => {
      expect(screen.getByText("침투 테스트 완료")).toBeInTheDocument();
      expect(screen.getByText(/성공: 3/)).toBeInTheDocument();
      expect(screen.getByText(/실패: 1/)).toBeInTheDocument();
    });
  });

  it("GIVEN connection established WHEN rendered THEN shows connected indicator", async () => {
    render(<ExploitLiveStream exploitSessionId="test-session" />);

    await waitFor(() => {
      const indicator = document.querySelector(".bg-green-500");
      expect(indicator).toBeInTheDocument();
    });
  });

  it("GIVEN output event WHEN received THEN displays collapsible output", async () => {
    render(<ExploitLiveStream exploitSessionId="test-session" />);

    await waitFor(() => {
      expect(MockEventSource.instances).toHaveLength(1);
    });

    const eventSource = MockEventSource.instances[0];
    eventSource.emit("output", {
      tool: "sqlmap",
      output: "Database enumeration completed\nFound 5 tables",
      iteration: 2,
    });

    await waitFor(() => {
      expect(screen.getByText("sqlmap")).toBeInTheDocument();
      expect(screen.getByText("출력 보기")).toBeInTheDocument();
    });
  });
});
